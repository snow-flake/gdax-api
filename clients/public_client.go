package clients

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strconv"
	"time"
)

//
//
//

type GdaxProductItem struct {
	ID             string `json:"id"`
	BaseCurrency   string `json:"base_currency"`
	QuoteCurrency  string `json:"quote_currency"`
	BaseMinSize    string `json:"base_min_size"`
	BaseMaxSize    string `json:"base_max_size"`
	QuoteIncrement string `json:"quote_increment"`
}
type GdaxProductsResponse []GdaxProductItem

func GetProducts(client *Client) (GdaxProductsResponse, error) {
	// Get Products
	// Get a list of available currency pairs for trading.
	//
	// HTTP REQUEST
	// GET /products
	//
	// HTTP RESPONSE
	// [
	//     {
	//         "id": "BTC-USD",
	//         "base_currency": "BTC",
	//         "quote_currency": "USD",
	//         "base_min_size": "0.01",
	//         "base_max_size": "10000.00",
	//         "quote_increment": "0.01"
	//     }
	// ]
	//
	// DETAILS
	// The base_min_size and base_max_size fields define the min and max order size. The quote_increment field specifies the min order price as well as the price increment.
	//
	// The order price must be a multiple of this increment (i.e. if the increment is 0.01, order prices of 0.001 or 0.021 would be rejected).
	//
	output := []GdaxProductItem{}
	_, err := client.Get("/products", url.Values{}, &output)
	return output, err
}

//
//
//

type GdaxTimeResponse struct {
	Iso   time.Time `json:"iso"`
	Epoch float64   `json:"epoch"`
}

func GetTime(client *Client) (*GdaxTimeResponse, error) {
	// Get the API server time.
	// HTTP REQUEST
	//  GET /time
	// HTTP RESPONSE
	// {
	//     "iso": "2015-01-07T23:47:25.201Z",
	//     "epoch": 1420674445.201
	// }
	//
	// EPOCH
	//  The epoch field represents decimal seconds since Unix Epoch
	//
	output := &GdaxTimeResponse{}
	_, err := client.Get("/time", url.Values{}, output)
	return output, err
}

//
//
//

type GdaxCurrency struct {
	ID      string  `json:"id"`
	Name    string  `json:"name"`
	MinSize float64 `json:"min_size"`
}
type GdaxCurrenciesResponse []GdaxCurrency

func GetCurrencies(client *Client) (GdaxCurrenciesResponse, error) {
	// Currencies
	// Get currencies
	// List known currencies.
	// HTTP REQUEST
	//  GET /currencies
	// HTTP RESPONSE
	// [{
	//     "id": "BTC",
	//     "name": "Bitcoin",
	//     "min_size": "0.00000001"
	// }, {
	//     "id": "USD",
	//     "name": "United States Dollar",
	//     "min_size": "0.01000000"
	// }]
	//
	// Not all currencies may be currently in use for trading.
	// CURRENCY CODES
	// Currency codes will conform to the ISO 4217 standard where possible. Currencies which have or had no representation in ISO 4217 may use a custom code.
	// Code  Description
	// BTC Bitcoin
	//

	type AutoGeneratedResponse struct {
		ID      string `json:"id"`
		Name    string `json:"name"`
		MinSize string `json:"min_size"`
	}
	tmp := []AutoGeneratedResponse{}
	_, err := client.Get("/currencies", url.Values{}, &tmp)

	output := []GdaxCurrency{}
	for _, row := range tmp {
		min_size, err := strconv.ParseFloat(row.MinSize, 64)
		if nil != err {
			return []GdaxCurrency{}, err
		}
		output = append(output, GdaxCurrency{
			ID:      row.ID,
			Name:    row.Name,
			MinSize: min_size,
		})
	}
	return output, err
}

//
//
//

type GdaxProduct24HrStatsResponse struct {
	Open        float64 `json:"open"`
	High        float64 `json:"high"`
	Low         float64 `json:"low"`
	Last        float64 `json:"last"`
	Volume      float64 `json:"volume"`
	Volume30Day float64 `json:"volume,omitempty"`
}

func GetProduct24HrStats(client *Client, product_id string) (*GdaxProduct24HrStatsResponse, error) {
	// Get 24hr Stats
	// Get 24 hr stats for the product. volume is in base currency units. open, high, low are in quote currency units.
	//
	// HTTP REQUEST
	//   GET /products/<product-id>/stats
	// HTTP RESPONSE
	// {
	//     "open": "34.19000000",
	//     "high": "95.70000000",
	//     "low": "7.06000000",
	//     "volume": "2.41000000"
	// }
	//
	type AutoGeneratedResponse struct {
		Open        string `json:"open"`
		High        string `json:"high"`
		Low         string `json:"low"`
		Volume      string `json:"volume"`
		Last        string `json:"last"`
		Volume30Day string `json:"volume_30day"`
	}

	tmp := &AutoGeneratedResponse{}
	_, err := client.Get(fmt.Sprintf("/products/%s/stats", product_id), url.Values{}, tmp)

	open, err := strconv.ParseFloat(tmp.Open, 64)
	if nil != err {
		return nil, err
	}
	high, err := strconv.ParseFloat(tmp.High, 64)
	if nil != err {
		return nil, err
	}
	low, err := strconv.ParseFloat(tmp.Low, 64)
	if nil != err {
		return nil, err
	}
	volume, err := strconv.ParseFloat(tmp.Volume, 64)
	if nil != err {
		return nil, err
	}
	last, err := strconv.ParseFloat(tmp.Last, 64)
	if nil != err {
		return nil, err
	}
	volume_30day, err := strconv.ParseFloat(tmp.Volume30Day, 64)
	if nil != err && tmp.Volume30Day != "" {
		return nil, err
	}
	output := &GdaxProduct24HrStatsResponse{
		Open:        open,
		High:        high,
		Low:         low,
		Volume:      volume,
		Last:        last,
		Volume30Day: volume_30day,
	}
	return output, err
}

//
//
//

type GdaxProductHistoricRate struct {
	Time   time.Time `json:"0"`
	Low    float64   `json:"1"`
	High   float64   `json:"2"`
	Open   float64   `json:"3"`
	Close  float64   `json:"4"`
	Volume float64   `json:"5"`
}
type GdaxProductHistoricRatesResponse []GdaxProductHistoricRate

type HistoricRateGranularity int

const (
	HistoricRateGranularity_1s   = 1
	HistoricRateGranularity_15s  = 15
	HistoricRateGranularity_30s  = 30
	HistoricRateGranularity_1m   = 60
	HistoricRateGranularity_5m   = 60 * 5
	HistoricRateGranularity_15m  = 60 * 15
	HistoricRateGranularity_30m  = 60 * 30
	HistoricRateGranularity_1hr  = 60 * 60
	HistoricRateGranularity_6hr  = 60 * 60 * 6
	HistoricRateGranularity_12hr = 60 * 60 * 12
	HistoricRateGranularity_1day = 60 * 60 * 24
)

func GetProductHistoricRates(client *Client, product_id string, start *time.Time, end *time.Time, granularity HistoricRateGranularity) (GdaxProductHistoricRatesResponse, error) {
	// Get Historic Rates
	// Historic rates for a product. Rates are returned in grouped buckets based on requested granularity.
	//
	// HTTP REQUEST
	// GET /products/<product-id>/candles
	//
	// PARAMETERS
	// Param Description
	// start Start time in ISO 8601
	// end End time in ISO 8601
	// granularity Desired timeslice in seconds
	//
	// HTTP RESPONSE
	// [
	//     [ time, low, high, open, close, volume ],
	//     [ 1415398768, 0.32, 4.2, 0.35, 4.2, 12.3 ],
	//     ...
	// ]
	//
	// RESPONSE ITEMS
	// Each bucket is an array of the following information:
	//
	// time bucket start time
	// low lowest price during the bucket interval
	// high highest price during the bucket interval
	// open opening price (first trade) in the bucket interval
	// close closing price (last trade) in the bucket interval
	// volume volume of trading activity during the bucket interval
	//
	args := url.Values{
		"granularity": []string{fmt.Sprintf("%d", granularity)},
	}
	if nil != start {
		args["start"] = []string{start.Format("2006-01-02T15:04:05Z")}
	}
	if nil != end {
		args["end"] = []string{end.Format("2006-01-02T15:04:05Z")}
	}
	tmp := [][]json.Number{}
	_, err := client.Get(fmt.Sprintf("/products/%s/candles", product_id), args, &tmp)

	output := make([]GdaxProductHistoricRate, 0, len(tmp))
	for _, row := range tmp {
		timeSeconds, _ := row[0].Int64()
		low, _ := row[1].Float64()
		high, _ := row[2].Float64()
		open, _ := row[3].Float64()
		close, _ := row[4].Float64()
		volume, _ := row[5].Float64()

		item := GdaxProductHistoricRate{
			Time:   time.Unix(timeSeconds, 0),
			Low:    low,
			High:   high,
			Open:   open,
			Close:  close,
			Volume: volume,
		}
		output = append(output, item)
	}
	return output, err
}

//
//
//

type GdaxProductTrade struct {
	Time    time.Time `json:"time"`
	TradeID int       `json:"trade_id"`
	Price   float64   `json:"price"`
	Size    float64   `json:"size"`
	Side    string    `json:"side"`
}
type GdaxProductTradesResponse []GdaxProductTrade

func GetProductTrades(client *Client, product_id string) (GdaxProductTradesResponse, error) {
	// Get Trades
	// List the latest trades for a product.
	//
	// HTTP REQUEST
	// GET /products/<product-id>/trades
	//
	// HTTP RESPONSE
	// [{
	//     "time": "2014-11-07T22:19:28.578544Z",
	//     "trade_id": 74,
	//     "price": "10.00000000",
	//     "size": "0.01000000",
	//     "side": "buy"
	// }, {
	//     "time": "2014-11-07T01:08:43.642366Z",
	//     "trade_id": 73,
	//     "price": "100.00000000",
	//     "size": "0.01000000",
	//     "side": "sell"
	// }]
	//
	// SIDE
	// The trade side indicates the maker order side. The maker order is the order that was open on the order book. buy side indicates a down-tick because the maker was a buy order and their order was removed. Conversely, sell side indicates an up-tick.
	//
	type AutoGeneratedResponse struct {
		Time    time.Time `json:"time"`
		TradeID int       `json:"trade_id"`
		Price   string    `json:"price"`
		Size    string    `json:"size"`
		Side    string    `json:"side"`
	}
	tmp := []AutoGeneratedResponse{}
	_, err := client.Get(fmt.Sprintf("/products/%s/trades", product_id), url.Values{}, &tmp)

	output := []GdaxProductTrade{}
	for _, row := range tmp {
		price, err := strconv.ParseFloat(row.Price, 64)
		if nil != err {
			return []GdaxProductTrade{}, err
		}
		size, err := strconv.ParseFloat(row.Size, 64)
		if nil != err {
			return []GdaxProductTrade{}, err
		}
		output = append(output, GdaxProductTrade{
			Time:    row.Time,
			TradeID: row.TradeID,
			Price:   price,
			Size:    size,
			Side:    row.Side,
		})
	}

	return output, err
}

//
//
//

type GdaxProductTickerResponse struct {
	TradeID int       `json:"trade_id"`
	Price   float64   `json:"price"`
	Size    float64   `json:"size"`
	Bid     float64   `json:"bid"`
	Ask     float64   `json:"ask"`
	Volume  float64   `json:"volume"`
	Time    time.Time `json:"time"`
}

func GetProductTicker(client *Client, product_id string) (*GdaxProductTickerResponse, error) {
	// Get Product Ticker
	// Snapshot information about the last trade (tick), best bid/ask and 24h volume.
	//
	// HTTP REQUEST
	//  GET /products/<product-id>/ticker
	// HTTP RESPONSE
	// {
	//   "trade_id": 4729088,
	//   "price": "333.99",
	//   "size": "0.193",
	//   "bid": "333.98",
	//   "ask": "333.99",
	//   "volume": "5957.11914015",
	//   "time": "2015-11-14T20:46:03.511254Z"
	// }
	//
	// REAL-TIME UPDATES
	//
	// Polling is discouraged in favor of connecting via the websocket stream and listening for match messages.
	//

	type AutoGeneratedResponse struct {
		TradeID int       `json:"trade_id"`
		Price   string    `json:"price"`
		Size    string    `json:"size"`
		Bid     string    `json:"bid"`
		Ask     string    `json:"ask"`
		Volume  string    `json:"volume"`
		Time    time.Time `json:"time"`
	}
	tmp := &AutoGeneratedResponse{}
	_, err := client.Get(fmt.Sprintf("/products/%s/ticker", product_id), url.Values{}, tmp)

	output := &GdaxProductTickerResponse{
		TradeID: tmp.TradeID,
		Price:   0.0,
		Size:    0.0,
		Bid:     0.0,
		Ask:     0.0,
		Volume:  0.0,
		Time:    tmp.Time,
	}
	if price, err := strconv.ParseFloat(tmp.Price, 64); err != nil && tmp.Price != "" {
		return nil, err
	} else {
		output.Price = price
	}
	if size, err := strconv.ParseFloat(tmp.Size, 64); err != nil && tmp.Size != "" {
		return nil, err
	} else {
		output.Size = size
	}
	if bid, err := strconv.ParseFloat(tmp.Bid, 64); err != nil && tmp.Bid != "" {
		return nil, err
	} else {
		output.Bid = bid
	}
	if ask, err := strconv.ParseFloat(tmp.Ask, 64); err != nil && tmp.Ask != "" {
		return nil, err
	} else {
		output.Ask = ask
	}
	if volume, err := strconv.ParseFloat(tmp.Volume, 64); err != nil && tmp.Volume != "" {
		return nil, err
	} else {
		output.Volume = volume
	}
	return output, err
}

//
//
//

type GdaxProductOrderBookItemAggregated struct {
	Price     float64
	Size      float64
	NumOrders int64
}
type GdaxProductOrderBookItemNonAggregated struct {
	Price   float64
	Size    float64
	OrderId string
}
type GdaxProductOrderBookResponseLevel1 struct {
	Sequence int64
	Bid      GdaxProductOrderBookItemAggregated
	Ask      GdaxProductOrderBookItemAggregated
}
type GdaxProductOrderBookResponseLevel2 struct {
	Sequence int64
	Bids     []GdaxProductOrderBookItemAggregated
	Asks     []GdaxProductOrderBookItemAggregated
}
type GdaxProductOrderBookResponseLevel3 struct {
	Sequence int64
	Bids     []GdaxProductOrderBookItemNonAggregated
	Asks     []GdaxProductOrderBookItemNonAggregated
}

func GetProductOrderBookLevel1(client *Client, product_id string) (*GdaxProductOrderBookResponseLevel1, error) {
	args := url.Values{
		"level": []string{"1"},
	}
	tmp := map[string]interface{}{}
	_, err := client.Get(fmt.Sprintf("/products/%s/book", product_id), args, &tmp)
	if nil != err {
		return nil, err
	}

	sequence := int64(tmp["sequence"].(float64))
	bids := tmp["bids"].([]interface{})
	asks := tmp["asks"].([]interface{})

	output := &GdaxProductOrderBookResponseLevel1{
		Sequence: sequence,
	}

	if len(bids) > 0 {
		bidItem, err := parseGdaxProductOrderBookItemAggregated(bids[0])
		if err != nil {
			return nil, err
		}
		output.Bid = *bidItem
	}
	if len(asks) > 0 {
		askItem, err := parseGdaxProductOrderBookItemAggregated(asks[0])
		if err != nil {
			return nil, err
		}
		output.Ask = *askItem
	}

	return output, nil
}

func GetProductOrderBookLevel2(client *Client, product_id string) (*GdaxProductOrderBookResponseLevel2, error) {
	args := url.Values{
		"level": []string{"2"},
	}
	tmp := map[string]interface{}{}
	_, err := client.Get(fmt.Sprintf("/products/%s/book", product_id), args, &tmp)

	sequence := int64(tmp["sequence"].(float64))
	bids := tmp["bids"].([]interface{})
	asks := tmp["asks"].([]interface{})

	output := &GdaxProductOrderBookResponseLevel2{
		Sequence: sequence,
		Bids:     make([]GdaxProductOrderBookItemAggregated, 0, len(bids)),
		Asks:     make([]GdaxProductOrderBookItemAggregated, 0, len(asks)),
	}

	for _, bid := range bids {
		item, err := parseGdaxProductOrderBookItemAggregated(bid)
		if err != nil {
			return nil, err
		}
		output.Bids = append(output.Bids, *item)
	}
	for _, ask := range asks {
		item, err := parseGdaxProductOrderBookItemAggregated(ask)
		if err != nil {
			return nil, err
		}
		output.Asks = append(output.Asks, *item)
	}
	return output, err
}

func GetProductOrderBookLevel3(client *Client, product_id string) (*GdaxProductOrderBookResponseLevel3, error) {
	args := url.Values{
		"level": []string{"3"},
	}
	tmp := map[string]interface{}{}
	_, err := client.Get(fmt.Sprintf("/products/%s/book", product_id), args, &tmp)

	sequence := int64(tmp["sequence"].(float64))
	bids := tmp["bids"].([]interface{})
	asks := tmp["asks"].([]interface{})

	output := &GdaxProductOrderBookResponseLevel3{
		Sequence: sequence,
		Bids:     make([]GdaxProductOrderBookItemNonAggregated, 0, len(bids)),
		Asks:     make([]GdaxProductOrderBookItemNonAggregated, 0, len(asks)),
	}

	for _, bid := range bids {
		item, err := parseGdaxProductOrderBookItemNonAggregated(bid)
		if err != nil {
			return nil, err
		}
		output.Bids = append(output.Bids, *item)
	}
	for _, ask := range asks {
		item, err := parseGdaxProductOrderBookItemNonAggregated(ask)
		if err != nil {
			return nil, err
		}
		output.Asks = append(output.Asks, *item)
	}
	return output, err
}

func parseGdaxProductOrderBookItemAggregated(raw_row interface{}) (*GdaxProductOrderBookItemAggregated, error) {
	row := raw_row.([]interface{})
	price, _ := row[0].(string)
	priceFloat64, err := strconv.ParseFloat(price, 64)
	if err != nil {
		return nil, err
	}
	size, _ := row[1].(string)
	sizeFloat64, err := strconv.ParseFloat(size, 64)
	if err != nil {
		return nil, err
	}
	numOrders, _ := row[2].(float64)
	numOrdersInt64 := int64(numOrders)

	return &GdaxProductOrderBookItemAggregated{
		Price:     priceFloat64,
		Size:      sizeFloat64,
		NumOrders: numOrdersInt64,
	}, nil
}

func parseGdaxProductOrderBookItemNonAggregated(raw_row interface{}) (*GdaxProductOrderBookItemNonAggregated, error) {
	row := raw_row.([]interface{})
	price, _ := row[0].(string)
	priceFloat64, err := strconv.ParseFloat(price, 64)
	if err != nil {
		return nil, err
	}
	size, _ := row[1].(string)
	sizeFloat64, err := strconv.ParseFloat(size, 64)
	if err != nil {
		return nil, err
	}
	orderId := row[2].(string)

	return &GdaxProductOrderBookItemNonAggregated{
		Price:   priceFloat64,
		Size:    sizeFloat64,
		OrderId: orderId,
	}, nil
}

//
//
//
